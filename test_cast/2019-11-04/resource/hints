
#1.	1.2	描述两个字符串是否互为字符重排的含义。现在，看看你提供的定义，你能否根据这个定义检查字符串？

#2.	3.1	栈只是一个数据结构，其中最近添加的元素首先被删除。你能用一个数组来模拟单个栈吗？请记住，有很多可能的解法且每个解法都有其利弊。

#3.	2.4	这个问题有很多解法，其中大部分都有最优的运行时间。有些代码比其他代码更短，更干净。你可以想出不同的解法吗？

#4.	4.10	如果T2是T1的子树，它的中序遍历将如何与T1的比较？它的前序和后序遍历如何？

#5.	2.6	回文数在向前写和向后写时是相同的。如果你颠倒链表会怎样？

#6.	4.12	尝试简化问题。如果路径必须从根开始会如何？

#7.	2.5	当然，你可以将链表转换为整数，计算总和，然后将其转换回新的链表。如果你在面试中这样做，面试官可能会接受答案，然后看看你在不能将其转换为数字然后返回的情况下，还能否做到这一点。

#8.	2.2	如果你知道链表大小，会怎么样？找到最后第k个元素和找到第x个元素有何区别？

#9.	2.1	你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。

#10.	4.8	如果每个节点都有一个到其父节点的链接，我们可以利用9.2节问题2.7的方法。然而，面试官可能不会让我们作出这样的假设。

#11.	4.10	中序遍历无法告诉我们更多。毕竟，每个具有相同值的二叉搜索树（不管结构如何）将具有相同的中序遍历。这也就是中序遍历的含义：内容是有序的（如果它在二叉搜索树这种特定情况下不起作用，那么对于一般二叉树来说它肯定不起作用）。然而，前序遍历更具指示性。

#12.	3.1	我们可以通过将数组的前三分之一分配到第一个栈、第二个三分之一分配到第二个栈、最后的第三个三分之一分配到第三个栈，来模拟数组中的三个栈。然而，实际上某个栈可能比其他的大得多。能更灵活地分配吗？

#13.	2.6	用栈试试。

#14.	4.12	不要忘记路径可能会重叠。例如，如果你正在寻找总和6，那么路径1 -> 3 -> 2和1 -> 3 -> 2 -> 4 -> 6 -> 2都是有效的。

#15.	3.5	排序数组的一种方法是遍历数组，并将每个元素按排序顺序插入到一个新数组中。你可以用一个栈实现吗？

#16.	4.8	第一个共同的祖先是最深的节点，这样p和q都是后代。想想你要如何识别这个节点。

#17.	1.8	如果你在找到0时清除了行和列，则可能会清理整个矩阵。在对矩阵进行任何更改之前，首先尝试找到所有的0。

#18.	4.10	你可能得出结论，如果T2.preorderTraversal()是T1.preorderTraversal()的子字符串，则T2是T1的子树。这几乎是事实，除非树可能有重复的值。假设T1和T2具有所有重复值，但结构不同。即使T2不是T1的子树，前序遍历看起来也是一样的。你如何处理这样的情况？

#19.	4.2	最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？

#20.	2.7	你可以在O(A + B)的时间和额外的O(1)空间中做到这一点，也就是说，你不需要一个散列表（尽管你可以用一个散列表来完成）。

#21.	4.4	考虑平衡树的定义。你可以检查单个节点的条件吗？你可以检查每个节点吗？

#22.	3.6	可以考虑为狗和猫保留一个链表，然后遍历它找到第一只狗（或猫）。这样做的影响是什么？

#23.	1.5	从容易的事情开始。你能分别检查一下每一个条件吗？

#24.	2.4	考虑元素不必保持相同的相对顺序。我们只需要确保小于基准点的元素必须位于比基准点大的元素之前。这有助于你想出更多的解法吗？

#25.	2.2	如果你不知道链表的大小，你能计算它吗？这将如何影响运行时间？

#26.	4.7	构建表示依赖关系的有向图。每个节点都是一个项目，如果B依赖于A（A必须在B之前构建），则从A到B存在一个边。你也可以用其他对你而言更便捷的方式构建。

#27.	3.2	注意最小的元素不会经常变化。它只在添加更小的元素或最小的元素被弹出时才发生变化。

#28.	4.8	你如何弄清p是否为节点n的后代？

#29.	2.6	假设你有链表的长度。你可以实现这个递归吗？

#30.	2.5	尝试递归。假设你有两个链表，A = 1 -> 5 -> 9（代表951）和B = 2 -> 3 -> 6 -> 7（代表7632），以及一个操作链表其余部分的函数（5 -> 9和3 -> 6 -> 7）。你能用这个来创建求和方法吗？sum(1 -> 5 -> 9, 2 -> 3 -> 6 -> 7)和sum(5 -> 9, 3 -> 6 -> 7)之间有何关系？

#31.	4.10	尽管问题似乎源于重复的值，但不止如此。问题是，前序遍历是相同的，只是因为我们跳过了空节点（因为它们是空的）。考虑在访问到空节点时往前序遍历的字符串中插入一个占位符。把空节点记录为一个“真正的”节点，你就可以区分出不同的结构了。

#32.	3.5	假设二级栈已排序。你能按顺序插入元素吗？你可能需要一些额外的存储空间。你可以使用什么额外的存储？

#33.	4.4	如果你开发了一个蛮力解法，请注意它的运行时间。如果你是用于计算每个节点的子树的高度，那么该算法会很低效。

#34.	1.9	如果一个字符串是另一个字符串的旋转，那么它就是在某个特定点上的旋转。例如，字符串waterbottle在3处的旋转意味着在第三个字符处切割waterbottle，并在左半部分（wat）之前放置右半部分（erbottle）。

#35.	4.5	如果使用前序遍历来遍历树，元素的顺序是正确的，这是否表明树实际上是有序的？有重复元素会发生什么？如果允许重复元素，它们必须位于特定的一边（通常是左边）。

#36.	4.8	从根节点开始。你能确定根是第一个共同祖先吗？如果不是，你能分辨出第一个共同祖先在根节点的哪一边吗？

#37.	4.10	或者用递归法处理这个问题。给定一个特殊节点T1，可以检查它的子树是否匹配T2吗？

#38.	3.1	如果你想考虑灵活划分，可以移动栈。你能保证使用所有可用的容量吗？

#39.	4.9	每个数组中的第一个值是多少？

#40.	2.1	没有额外的空间，你需要O(N2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。

#41.	2.2	尝试用递归法实现。如果你能找到(k  1)到最后一个元素，可以找到第k个元素吗？

#42.	4.11	在这个问题中务必要小心，以确保每个节点的可能性相同，并且你的解法不会降低标准二叉搜索树算法的速度（如插入、查找和删除）。另外，请记住，即使你假设它是一个平衡的二叉搜索树，也不意味着树是满的、完整的、完美的。

#43.	3.5	保持二级栈的排序顺序，最大的元素在顶部。使用主栈进行额外的存储。

#44.	1.1	用散列表试试。

#45.	2.7	举例子能帮到你。画一个相交的链表和两个不相交的等价链表（值）的图片。

#46.	4.8	尝试递归方法。检查p和q是否为左子树和右子树的后代。如果它们是不同的树的后代，那么当前节点是第一个共同的祖先。如果它们是同一子树的后代，则该子树保存第一个共同祖先。现在，你该如何有效地实现它呢？

#47.	4.7	看看这个图。是否可以首先构建可识别的节点？

#48.	4.9	根是每个数组中必须包含的第一个值。相对于右子树中的值，左子树中的值顺序如何？左子树值是否需要在右子树之前插入？

#49.	4.4	如果你可以修改二叉树节点类，允许节点存储子树的高度，会如何？

#50.	2.8	这个问题实际上可以分为两个部分。首先，检测链表是否有循环。第二，找出循环开始的位置。

#51.	1.7	尝试逐层思考。你能旋转某个特定图层吗？

#52.	4.12	如果每条路径必须从根开始，就从根开始遍历所有可能的路径。可以在遍历的同时追踪和，每次找到一个路径满足我们的目标和，就增加totalpaths的值。现在，如何将它扩展到可以在任何地方开始呢？记住：只需要一个蛮力算法即可完成。你可以稍后再优化。

#53.	1.3	从尾到头开始修改字符串通常最容易。

#54.	4.11	这是你创建的二叉搜索树类，因此你可以在树结构或节点上维护任何信息（假如它没有其他的负面影响，比如插入速度变慢很多）。事实上，面试问题可能会说明这是你自己的类。你可能需要存储一些额外信息来达到这样的效率。

#55.	2.7	首先要确定是否有交叉点。

#56	3.6	让我们假设用不同的列表存储猫和狗。怎样才能找到所有物种中最老的动物呢？要有创意。

#57.	4.5	作为一个二叉搜索树，并不是说每个节点都满足left.value <= current.value < right就够了。左边的每个节点必须小于当前节点，该节点还必须小于右边的所有节点。

#58.	3.1	试着把数组看作是循环的，这样数组的结尾就“环绕”到了数组的开始部分。

#59.	3.2	如果保持追踪每个栈节点的额外数据会怎么样？什么样的数据可能更容易解决这个问题呢？

#60.	4.7	如果你确定一个节点没有任何指进来的边，那么它肯定可以被构建。找到这个节点（可能是多个）并将其添加到构建的顺序中。那么，这对向外的边意味着什么呢？

#61.	2.6	在递归方法中（我们有链表的长度），中点是基线条件，即isPermutation(middle)是true。节点x是紧挨着middle的左侧的一个节点：该如何检查x -> middle -> y是否形成回文？现在假设检查通过。前一个节点a又该如何检查？如果x -> middle -> y是回文，怎么检查a -> x -> middle -> y -> b是回文？

#62.	4.11	作为一种朴素的“蛮力”算法，你能使用树遍历算法来实现这个算法吗？它的运行时间是多少？

#63.	3.6	想想现实生活中你是怎么做的。你有一个按时间排序的狗列表和一个按时间排序的猫列表。你需要什么数据才能找到最老的动物？你将如何维护这些数据？

#64.	3.3	你需要追踪每个子栈的大小。当一个栈已满时，你可能需要创建一个新栈。

#65.	2.7	注意，两个相交链表的最后节点始终相同。一旦它们相交，之后的所有节点将相等。

#66.	4.9	左子树值与右子树值之间本质上可以是任何关系。可以在右子树之前插入左子树值，也可以反转（右子树的值在左边）或采用任意其他顺序。

#67.	2.2	你可能会发现返回多个值大有用处。有些语言不直接支持这一点，但基本上使用任何语言都有解决方法。这些解决方法有哪些？

#68.	4.12	为了将其扩展到从任何地方开始的路径，我们可以对所有节点重复此过程。

#69.	2.8	要确定是否有一个循环，请尝试9.2.3节介绍的“快行指针”方法。让一个指针比另一个指针快。

#70.	4.8	在更简单的算法中，我们有一个方法表明x是n的后代，另一个方法是递归查找第一个共同的祖先。这样是在子树中反复搜索相同的元素。我们应该将其合并成一个firstCommonAncestor方法。那么什么样的返回值会给我们需要的信息？

#71.	2.5	确保你考虑到了链表的长度不同的情况。

#72.	2.3	列出清单1 -> 5 -> 9 -> 12。删除9会使它看起来像1 -> 5 -> 12。你只能访问9节点。你能让它看起来像正确的答案吗？

#73.	4.2	你可以通过找到“理想”的下一个要添加的元素和多次调用insertValue来实现。这样效率会有点儿低，因为你必须反复遍历树。尝试用递归代替。你能把这个问题分解为子问题吗？

#74.	1.8	你能只用额外的O(N)空间而不是O(N2)吗？在为0的单元格列表中你真正需要的是什么信息？

#75.	4.11	或者，你可以选择一个随机的深度来遍历，然后随机遍历，当你达到该深度时停止。不过，请考虑一下，这样能行吗？

#76.	2.7	你可以通过遍历到每个链表的末尾并比较它们的尾节点来确定两个链表是否相交。

#77.	4.12	如果你已经设计了以上描述的算法，那么在平衡树中你会有一个O(NlogN)的算法。这是因为共N个节点，在最坏情况下，每个节点的深度是O(logN)。节点上方的每个节点都会访问一次。因此，N个节点将被访问O(logN)的时间。有一种优化算法，其运行时间为O(N)。

#78.	3.2	考虑让每个节点知道它“子栈”的最小值（包括它下面的所有元素，以及它本身）。

#79.	4.6	想想中序遍历是如何工作的，并尝试对其进行“逆向工程”。

#80.	4.8	firstCommonAncestor函数可以返回第一个共同的祖先（如果p和q都包含在树里），如果p在树上而q不在，返回p；如果q在树上而p不在，返回q；否则，返回空。

#81.	3.3	在一个特定的子栈中弹出一个元素意味着一些栈没有满。这是个问题吗？没有正确的答案，但你应该考虑如何处理这个问题。

#82.	4.9	把这个分解成子问题。使用递归法。如果你有左右子树的所有可能的序列，那么如何为整个树创建所有可能的序列呢？

#83.	2.8	你可以使用两个指针，一个指针移动速度是另一个指针的两倍。如果有环，两个指针会碰撞。它们将同时降落在同一地点。它们在哪里相遇？为什么呢？

#84.	1.2	有一种解法需要O(NlogN)的时间。另一种解法需要使用一些空间，但需要运行时间为O(N)。

#85.	4.7	一旦决定构建一个节点，它的出边可以被删除。完成此操作后，你是否可以找到其他空闲且清晰的节点来构建？

#86.	4.5	如果左边的每个节点必须小于或等于当前节点，那么这就等于左边最大的节点必须小于或等于当前节点。

#87.	4.12	在当前的蛮力算法中重复了什么工作？

#88.	1.9	本质上，我们是在寻找是否有一种方式可以把第一个字符串分成两部分，即x和y，如此一来，第一个字符串就是xy，第二个字符串就是yx。例如，x = wat，y = erbottle。那么，第一个字符串xy = waterbottle，第二个字符串yx = erbottlewat。

#89.	4.11	选择一个随机的深度对我们没有多大帮助。首先，在较低深度比更高深度有更多的节点。其次，即使重新平衡了这些概率，也可能走到一个“死胡同”，我们原想在深度为5处选择一个节点，却在深度为3处命中一个叶子。尽管重新平衡概率是一件有趣的事。

#90.	2.8	如果你还没有确定两个指针的起始位置，请尝试使用链表1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> ?，其中 ? 链接到另一个节点。试着让 ? 成为第一个节点（即9指向1，使得整个链表是一个循环）。然后让 ? 成为节点2，然后成为节点3，然后成为节点4。这一模式是什么？你能解释一下为什么会这样吗？

#91.	4.6	这只是逻辑方法中的一步：一个特定节点的后继节点是右子树的最左节点。如果没有右子树呢？

#92.	1.6	先做容易的事。压缩字符串，然后再比较长度。

#93.	2.7	现在，你需要查找链表在何处相交。假设链表长度相同。你可以怎么做？

#94.	4.12	从根开始考虑每个路径（有n个这样的路径）作为一个数组。该蛮力算法具体运作如下：拿着每个数组来寻找所有具有特定和的连续子序列。我们这样做是计算了所有子数组以及它们的和。把目光聚焦在这个小问题上可能会大有裨益。给定一个数组，你如何寻找具有特定和的所有连续子序列？同样，想想蛮力算法中的重复工作。

#95.	2.5	你的算法在形如9 -> 7 -> 8和6 -> 8 -> 5的链表上工作吗？仔细检查一下。

#96.	4.8	小心！你的算法处理只有一个节点的情况吗？会发生什么事？你可能要微调返回值。

#97.	1.5	“插入字符”选项和“删除字符”选项之间是何关系？这些需要分开检查吗？

#98.	3.4	队列和栈的主要区别是元素的顺序。队列删除最旧的项，栈删除最新的项。如果你只访问最新的项，那么如何从栈中删除最旧的项？

#99.	4.11	许多人提出的一种简单做法是从1到3之间选择一个随机数。如果是1，返回当前节点；如果是2，分支左；如果是3，分支右。该解法不起作用。为什么呢？你能调整一下使其运作吗？

#100.	1.7	旋转一个特定的层只意味着在4个数组中交换值。如果要求你在2个数组中交换值，你能做到吗？你能把它扩展到4个数组吗？

#101.	2.6	回到前面的提示。记住：返回多个值的方法有很多。你可以用一个新类来实现。

#102.	1.8	你可能需要一些数据存储来维护一个需要清零的行与列的列表。通过使用矩阵本身来存储数据，你是否可以把额外的空间占用减小到O(1)？

#103.	4.12	我们正在寻找和为targetSum的子数组。注意，可以在常数时间得到runningSumi的值，这是从元素0到元素i的和。一个从i到j的子数组和为targetSum，则 runningSumi-1 + targetSum必须等于runningSumj（试着画一个数组或一条数字线）。随着往下走，可以追踪runningSum，那么如何能快速查找i对应的使前面等式成立的值？

#104.	1.9	想想前面的提示。再想想当你将erbottlewat与它本身连接会发生什么。你得到了erbottlewaterbottlewat。

#105.	4.4	你不需要修改二叉树类来存储子树的高度。递归函数是否可以计算每个子树的高度，同时检查节点是否平衡？尝试让函数返回多个值。

#106.	1.4	你不必且也不应该生成所有的排列。这将极为低效。

#107.	4.3	尝试修改图形搜索算法，从根开始追踪深度。

#108.	4.12	尝试使用一个散列表，从runningSum的值映射到使用runningSum元素的个数。

#109.	2.5	对于后续问题：问题是，当链表的长度不一样时，一个链表的首部可能代表1000的位置，而另一个链表代表10的位置。如果你把它们做的一样长呢？有没有方法修改链表来做到这一点，而不改变它所代表的值？

#110.	1.6	注意不要把字符串重复连接在一起。这会非常低效。

#111.	2.7	如果两个链表长度相同，则可以在每个链表中向前遍历，直到找到一个公共的元素。现在，面对长度不同的链表，你该怎样调整？

#112.	4.11	之前的解法（在1到3之间选择一个随机数）不起作用是因为节点的概率不相等。例如，根会以1/3的概率返回，即使树中有50个以上的节点。显然，并非所有节点都具有1/3的概率，因此这些节点将具有不相同的概率。我们可以通过选择一个1和size_of_tree之间的随机数解决这一问题。这只解决了根节点的问题。剩下的节点呢？

#113.	4.5	相比于根据leftTree.max和rightTree.min来验证当前节点的值，我们可以翻转逻辑吗？验证左子树的节点以确保其小于current.value。

#114.	3.4	我们可以通过不断地删除最新的项（将这些项插入临时栈中）来删除栈中最老的项，直到得到一个元素为止。然后，在检索到最新项后，将所有元素返回。与此有关的问题是，每次在一行中做几个弹出操作（pop）将需要O(n)的时间。我们可以优化在一行中连续弹出这一场景吗？

#115.	4.12	一旦你完成了这样的算法，找出了和为给定值的所有连续子数组，试着将它应用到一棵树上。请记住，在遍历和修改散列表时，你可能需要在遍历回来时将散列表的“损坏”逆转。

#116.	4.2	想象一下，我们有一个createMinimalTree方法可以返回给定数组的最小树（但由于一些奇怪的原因不在树的根上操作）。你能用这个操作树的根节点吗？你能写出函数的基线条件吗？非常好！那基本上是整个函数了。

#117.	1.1	位向量有用吗？

#118.	1.3	你可能需要知道空格的数量。你能数一下吗？

#119.	4.11	之前解法存在的问题是一个节点的一侧可能有比另一侧更多的节点。因此，我们需要根据每个边上的节点数来加权左右概率。具体该怎么做呢？我们如何知道节点的数目？

#120.	2.7	尝试使用两个链表长度之间的差异。

#121.	1.4	作为回文排列的字符串有什么特征？

#122.	1.2	散列表有用吗？

#123.	4.3	从层号映射到该层节点的散列表或数组也许有些用处。

#124.	4.4	其实，你只需要一个checkHeight函数即可，它既可以计算高度，也可以平衡检查。可以使用整数返回值表示两者。

#125.	4.7	作为一种完全不同的方法：考虑从任意节点开始进行深度优先搜索。深度优先搜索和合法的编译顺序之间有何关系？

#126.	2.2	你能通过递归做到吗？想象一下，如果有两个指针指向相邻节点，它们通过链表以相同的速度移动。当一个到达链表的结尾时，另一个在哪里？

#127.	4.1	有两个众所周知的算法可以做到这一点。其利弊是什么？

#128.	4.5	把checkBST函数当作一个递归函数，保证每个节点在允许范围内(最小, 最大)。首先，这个范围是无限的。当我们遍历左边，最小的是负无穷大，最大的是root.value。你能实现这个递归函数，并且随着遍历而适当调整这些范围吗？

#129.	2.7	如果你通过长度差异向较长的链表中移动指针，则可以在链表相同时应用类似的方法。

#130.	1.5	你能一次完成三次检查吗？

#131.	1.2	两个重排的字符串应该具有相同的字符，但顺序不同。你可以让它们的顺序一样吗？

#132.	1.1	你能用O(N log N)的时间复杂度解决它吗？这样的解法会是什么样呢？

#133.	4.7	选择任意节点并对其进行深度优先搜索。一旦到达一个路径的末端，我们就知道这个节点可能是最后一个节点，因为没有节点依赖它。这对前面的节点意味着什么？

#134.	1.4	你试过散列表吗？你应该能把它降到O(N)的时间。

#135.	4.3	你应该能够提出一个既包括深度优先搜索又包含广度优先搜索的算法。

#136.	1.4	使用位向量可以减少空间使用吗？

#137.	5.1	把这个分成几个部分。先将精力放在清除适当的位上。

#138.	8.9	尝试简单构建法。

#139.	6.9	给定一个特定的柜子x，在哪轮将被切换状态（开或关）？

#140.	11.5	面试官说的笔是什么意思？可能有很多不同类型的笔。列出你可能想问的问题。

#141.	7.11	这并不像听起来那么复杂。首先列出系统中关键对象的列表，然后想想它们如何交互。

#142.	9.6	首先，先作一些假设。什么是你不需要构建的？

#143.	5.2	为了解决这个问题，试着想想如何用它来处理整数。

#144.	8.6	尝试简单构建法。

#145.	5.7	交换每一对意味着把偶数位移到左边，奇数位移到右边。你能把这个问题分成几个部分吗？

#146.	6.10	解法1：从一个简单的方法开始。你能把这些瓶子分成组吗？记住，一旦试纸呈阳性，就不能再使用它，但只要它呈阴性，就可以重新使用。

#147.	5.4	下一步：从每个蛮力解法开始。

#148.	8.14	我们能试试所有的可能性吗？这看起来像什么？

#149.	6.5	把玩水壶，来回倒水，看看你能否测量3夸脱或5夸脱以外的东西。这是一个开始。

#150.	8.7	方法1：假设你有abc的所有排列。你怎么用它来得到abcd的所有排列？

#151.	5.5	反向工程，从最外层到最内层。

#152.	8.1	自上而下地处理这个问题。小孩的最后一跳是什么？

#153.	7.1	请注意，“扑克牌”是非常广泛的。你可能要考虑一下这个问题的合理范围。

#154.	6.7	注意每个家庭都有一个女孩。

#155.	8.13	排列箱子会有什么帮助吗？

#156.	6.8	这实际上是一个算法问题，你应该这样做。给出一个蛮力算法，计算最坏情况下扔鸡蛋的次数，然后尝试优化。

#157.	6.4	在什么情况下其不会碰撞？

#158.	9.6	假设电子商务系统的其余部分已经处理完毕，只需要处理销售排名的分析部分。购买发生时我们可以以某种方式得到通知。

#159.	5.3	先试试蛮力解法。你能尝试一切可能性吗？

#160.	6.7	考虑将每个家庭写成Bs和Gs的序列。

#161.	8.8	你可以通过在打印之前检查是否有重复内容（或将它们添加到列表中）来处理此问题。你可以用散列表来做到这一点。在什么情况下，这样是可以的？在什么情况下，这可能不是一个很好的解法？

#162.	9.7	这个应用程序是重在写入还是重在读取？

#163.	6.10	解法1：有一种相对简单的方案，在最坏的情况下要花费28天的时间。不过，还有更好的方法。

#164.	11.5	考虑儿童笔的情况。这是什么意思？有什么不同的用例？

#165.	9.8	解决问题的范围。作为这个系统的一部分，你将要处理什么？

#166.	8.5	考虑将8乘以9看作是计算宽度为8、高度为9的矩阵中的单元数。

#167.	5.2	像0.893这样的数字（以10为底），每个数字代表什么？那么以2为底的0.10 010中的每个数字代表什么？

#168.	8.14	我们可以把每种可能性都看作是每个可以放置括号的地方。这意味着围绕每个操作符，使表达式在运算符上被分割。基线条件是什么？

#169.	5.1	要清除这些位，创建一个看起来像是一系列1，然后是0，然后是1的“位掩码”。

#170.	8.3	先试试蛮力算法。

#171.	6.7	虽然数学很难，但你可以试着使用数学方法。估算一下比如6个孩子的家庭可能会较为容易。这不会给你一个很好的数学证明方法，但可能会向你指出获得答案的正确方向。

#172.	6.9	在何种情况下柜子会在这个过程结束时被打开？

#173.	5.2	一个数字如0.893（以10为底）表示8×101 + 9×102 + 3×103。将此系统转换为以2为底。

#174.	8.9	假设我们有编写两对括号的所有有效方法。怎么用这个来得到编写三对括号的所有有效方法？

#175.	5.4	下一个：想象一个二进制数，在整个数中分布一串1和0。假设你把一个1翻转成0，把一个0翻转成1。在什么情况下数会更大？在什么情况下数会更小？



#176.	9.6	想想你对数据的新鲜度和准确性持有什么样的期望度。数据是否总是需要百分之百最新的？有些产品的准确性比其他产品更重要吗？

#177.	10.2	你如何检查两个单词是否互为变位词？想一想如何定义“变位词”。用你自己的话来解释一下。

#178.	8.1	如果知道跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？

#179.	7.8	白子和黑子应该是同一类吗？这有什么优点和缺点呢？

#180.	9.7	注意到有很多数据进来，但是人们可能并不会频繁地阅读数据。

#181.	6.2	分别计算赢得第一场比赛和赢得第二场比赛的概率，然后对其进行比较。

#182.	10.2	两个单词互为变位词是指含有相同的字符，但顺序不同。怎么才能把字符排好序呢？

#183.	6.10	解法2：为什么在测试和结果之间有这样大的时间延迟？这也是该问题没有只被当作“最小测试次数”提出来的原因。时间延迟是有原因的。

#184.	9.8	你认为流量分布的均匀性如何？所有的文件都有大致相同的流量吗？或者可能有一些非常受欢迎的文件？

#185.	8.7	方法1：abc的排列组合表示abc的所有组合方式。现在，我们要创建abcd的所有组合方式。选择abcd的特定组合，如bdca。这个bdca字符串也代表abc的一种排列方式：删除d，你会得到bca。那么给定字符串bca，你是否可以创建包含d 的所有“相关”排列组合？

#186.	6.1	你只能使用天平一次。这意味着必须使用所有或几乎所有的药瓶。还必须使用不同的处理方法，否则你无法将它们区分开来。

#187.	8.9	我们可以通过向两对括号的列表中添加第三对括号来生成三对括号的组合。我们要在其前面、周围、后面添加第三对括号。即()<SOLUTION>、(<SOLUTION>)、<SOLUTION>()。这样有效吗？

#188.	6.7	逻辑可能比数学容易。想象一下，我们把每次出生都写进了一个巨大的字符串，它由字符B和G组成。注意家庭的分组对于这个问题是无关紧要的。字符串的下一个字符是B 还是G 的概率是多少？

#189.	9.6	购买行为会非常频繁。你可能希望限制数据库写入。

#190.	8.8	如果你还没有解决8.7的问题，就先解决那个。

#191.	6.10	解法2：考虑同时运行多个测试。

#192.	7.6	解决拼图游戏的一个常见方法是将边缘和非边缘部分分开。你将如何以面向对象的方式来表示这一点？

#193.	10.9	先试试一种简单解法。但希望不要太简单。你应该能够借助矩阵是有序的这一实际情况。

#194.	8.13	我们可以按任一维度对箱子从大到小进行排序。这样我们会有箱子某一维度的局部顺序，在数组中后面的箱子必须出现在数组中前面的箱子之前。

#195.	6.4	只有三只蚂蚁都向同一个方向爬行，它们才不致相撞。三只蚂蚁都按顺时针爬行的概率是多少？

#196.	10.11	假设数组按升序排序。有什么办法可以把它调整为交替的高峰和低谷？

#197.	8.14	基本情况是我们有一个值，1或0。

#198.	7.3	首先确定问题的范围，并列出你所作的假设。作出合理的假设通常是可以的，但你需要使之明确。

#199.	9.7	这个系统会是重在写入：大量的数据被导入，但很少被读取。

#200.	8.7	方法1：给定一个字符串，比如bca，可以通过将d 插入到每个可能的位置：dbca、bdca、bcda、bcad，来创建abcd（其中abc顺序一定）的所有排列组合。给定abc的所有排列，你可以创建所有abcd的排列吗？

#201.	6.7	请注意生物学并没有改变，只有家庭停止生孩子的条件有所改变。每一次怀孕生男孩和生女孩的可能性均为50%。

#202.	5.5	如果A & B == 0，这意味着什么？

#203.	8.5	如果你想计算8×9矩阵中的单元格数，可以先计算4×9矩阵中的单元格数，然后加倍。

#204.	8.3	蛮力算法的运行时间可能为O(N)。如果试图击败那个运行时间，你认为会得到什么运行时间。什么样的算法具有该运行时间？

#205.	6.10	解法2：试着通过数字来猜出瓶子。如何检测到有毒的瓶子中的第一位数字？第二位数字呢？第三位数字呢？

#206.	9.8	你将如何处理生成的URL？

#207.	10.6	想想归并排序和快速排序。哪一个能更好地实现该算法？

#208.	9.6	你也想限制join操作，因为它们可能过于烦琐。

#209.	8.9	前面提示给出的解法存在的问题在于可能有重复的值。我们可以通过使用散列表来消除这种情况。

#210.	11.6	作假设要小心。谁是用户？他们在哪里使用这个？这看起来可能显而易见，但真正的答案可能大不相同。

#211.	10.9	可以在每一行进行二进制搜索。这需要多长时间？怎样才能做得更好？

#212.	9.7	考虑如何获取银行数据（拉或推?），系统将支持哪些功能，等等。

#213.	7.7	一如既往，确定问题范围。“好友关系”是双向的吗？存在状态信息吗？你支持群聊吗？

#214.	8.13	试着把它分解成子问题。

#215.	5.1	在开始或结束时很容易创建一个0的位掩码。但是，有一堆0时，你如何在中间创建一个零位掩码？简单的做法是，为左侧创建一个位掩码，然后为右侧创建一个位掩码。然后你可以合并两边。

#216.	7.11	文件和目录之间有何关系？

#217.	8.1	可以通过步数99、98、97的数量，来计算100步的数量。这对应孩子最后迈1步、2步或3步。我们把它们加起来还是相乘？也就是说，它是f(100) = f(99) + f(98)+ f(97) 或者f(100) = f(99)×f(98)×f(97)吗？

#218.	6.6	这是一个逻辑问题，而不是一个巧妙的单词问题。使用逻辑/数学/算法来解决该问题。

#219.	10.11	尝试遍历排序的数组。你可以交换元素直到将数组调整好吗？

#220.	11.5	你是否考虑过预期用途（书写等）和意外使用这两种情况？那安全如何保证？你不会想要一支对孩子来说有危险的笔。

#221.	6.10	解法2：小心边界情况。如果瓶子编号中的第三个数字与第一个或第二个数字相匹配呢？

#222.	8.8	试着获得每个字符的计数。例如，abcaac有3个a、2个c和1个b。

#223.	9.6	不要忘记一个产品可以在多个类别中列出。

#224.	8.6	你可以很容易地把最小的圆盘从一根柱子移到另一根柱子。把最小的两个圆盘从一根柱子移到另一根柱子也是小菜一碟。你能移动最小的三个圆盘吗？

#225.	11.6	在实际面试中，你还需要问有哪些可用的测试工具。

#226.	5.3	把0翻转到1可以合并两个1 的序列，但只有在这两个序列仅被一个0分隔时才可以。

#227.	8.5	想想你如何处理奇数。

#228.	7.8	什么类应该持有分数？

#229.	10.9	如果你正在考虑某个特定列，是否有办法快速消除该列（至少在某些情况下）？

#230.	6.10	解法2：你可以运行另外一天的测试，以不同的方式检查数字3。但是，再提醒一次，在这里要小心边界情况。

#231.	10.11	请注意，如果确保山峰位置正确，那么山谷也会在正确位置。因此，对数组x的迭代可以跳过每一个其他元素。

#232.	9.8	如果随机生成URL，是否需要担心冲突（两个文档具有相同URL）？如果是这样，你怎么处理呢？

#233.	6.8	作为第一种方法，你可以尝试类似二分查找的方法。从第50次或第75次，然后到第88次，等等。问题是，如果鸡蛋1从50层下落，那么你需要从第1层开始往下扔鸡蛋2，逐层往上走。最糟糕的情况下，这可能需要50次（第50次扔，第1次和第2次扔，直到第49次扔）。你能改进这一情况吗？

#234.	8.5	如果不同的递归调用有重复的工作，你可以缓存它吗？

#235.	10.7	向量有用吗？

#236.	9.6	缓存数据或排队任务适合哪里？

#237.	8.1	当“我们这样做然后那样做”时，将这些值相乘。当“我们这样做或者那样做”时，将这些值相加。

#238.	7.6	想想你在找到一块拼图时如何记录它的位置。是否应该按行和位置存储？

#239.	6.2	要计算玩法2 获胜的概率，首先要计算第1、2次投中，第3次未投中的概率。

#240.	8.3	你能以O(log N)的时间复杂度来解决这个问题吗？

#241.	6.10	解法3：将每条试纸测试后有毒与无毒当作二进制指标。

#242.	5.4	下一步：如果你将1翻转成0，0翻转成1，假设 0 -> 1位更大，那么它就会变大。你如何使用这个来创建下一个最大的数字（具有相同数量的1）？

#243.	8.9	或者，可以考虑通过移动字符串并在每个步骤添加左侧和右侧的括号来完成此操作。这会消除重复吗？如何知道能否添加左侧或右侧的括号？

#244.	9.6	根据你作出的假设，你甚至可以在没有数据库的情况下完成任务。这意味着什么？这是个好主意吗？

#245.	7.7	考虑可能有用的主要系统组件或技术，这是一个很好的问题。

#246.	8.5	如果你在做9×7（都是奇数），那么你可以换成4×7和5×7。

#247.	9.7	尽量减少不必要的数据库查询。如果你不需要永久存储数据库中的数据，那根本就不需要数据库。

#248.	5.7	你能创建一个代表偶数位的数字吗？那么你可以将偶数位移过一位吗？

#249.	6.10	解法3：如果每条试纸都是二进制指标，我们能否将整数键映射到一组10个的二进制指标，以使每个键具有唯一的配置（映射）？

#250.	8.6	考虑将最小的圆盘从柱X = 0 移动到柱Y = 2，使用柱Z = 1作为临时保留点，作为f(1, X = 0, Y = 2, Z = 1)的解题方案。移动最小的两个圆盘来表示f(2, X = 0, Y = 2, Z = 1)。给定你f(1, X = 0, Y = 2, Z = 1)和f(2, X = 0, Y = 2, Z = 1)的题目解法，你能解出f(3, X = 0, Y = 2, Z = 1)吗？

#251.	10.9	由于每列都进行了排序，因此如果该值小于此列中的最小值，则可知该值不能位于此列中。除此以外还能告诉你什么？

#252.	6.1	如果你把每个瓶子中的一粒药丸放在天平上，会怎么样？如果你从每个瓶子中取两粒药丸放在天平上，又会如何？

#253.	10.11	你是否一定要对数组进行排序？你可以用一个未排序的数组来做到这一点吗？

#254.	10.7	要想用更少的内存，你能试着处理多次吗？

#255.	8.8	要得到3个a、2个c和1个b的全排列，你首先需要选择一个起始字符：a、b或c。如果是a，那么你需要2个a、2个c和1个b的全排列。

#256.	10.5	尝试修改二分查找来处理这个问题。

#257.	11.1	这段代码有两个错误。

#258.	7.4	停车场有多个等级吗？它支持什么样的“特性”？它需要付费吗？什么类型的车辆？

#259.	9.5	你可能需要作出一些假设（部分原因在于这里没有面试官）。没关系。明确这些假设。

#260.	8.13	想想你必须做出的第一个决定。第一个决定是哪个箱子在底部。

#261.	5.5	如果A & B == 0，那就意味着A和B在相同位置没有1。把这个应用到问题的等式中。

#262.	8.1	这个方法的运行时间是多少？仔细想想。你能优化它吗？

#263.	10.2	你能利用标准排序算法吗？

#264.	6.9	注意：如果一个整数x能被a整除，并且b = x / a，那么x也可以被b整除。这是否意味着所有的数都有偶数个因子？

#265.	8.9	在每一步添加一个左或右括号将消除重复。每个子字符串在每一步都是各不相同的。因此，总字符串将是独一无二的。

#266.	10.9	如果值x小于列的开头，那么它也不能在右边的任何列中。

#267.	8.7	方法1：你可以通过计算abc的所有排列，然后在每个可能的位置插入d，从而创建abcd的所有排列。

#268.	11.6	我们想要测试哪些不同的功能和用途？

#269.	5.2	你将如何获得0.893中的第一个数字？如果乘以10，那么你会改变值得到8.93。如果乘以2，结果会是什么？

#270.	9.2	为了找到两个节点之间的连接，最好是运用广度优先搜索还是深度优先搜索？为什么？

#271.	7.7	你如何得知用户是否离线？

#272.	8.6	请注意，哪根柱子是源、目的地或暂存点并不重要。你可以通过f(2, X = 0, Y = 2, Z = 1)来计算f(2, X = 0, Y = 1, Z = 2)（将两个盘子从柱0移动到柱1，以柱2作为暂存点），然后将盘子3从柱0移动到柱2，计算f(2, X = 1, Y = 2, Z = 0)（将两个盘子从柱1移动到柱2，以柱0作为暂存点）。这个过程是怎样重复的？

#273.	8.4	如何从子集{a, b}中构建{a, b, c}的所有子集？

#274.	9.5	想一想如何为一台机器设计这个。你想要一个散列表吗？是如何工作的？

#275.	7.1	如果有的话，你会如何处理A？

#276.	9.7	工作应尽量异步完成。

#277.	10.11	假设你有{0, 1, 2}三个元素的序列，以任意顺序排列。写出这些元素所有可能的排列，以及如何把它们变成1是波峰的形式。

#278.	8.7	方法2：如果你拥有两个字符所有排列的子串，可以生成三个字符全排列的子串吗？

#279.	10.9	考虑行中的上一个提示。

#280.	8.5	或者，如果你在计算9×7，可以计算4×7，加倍，然后再加7。

#281.	10.7	尝试过一遍数据，把数降到一个数值范围，然后通过第二次遍历来查找一个特定的值。

#282.	6.6	假设只有一个蓝眼睛的人。那个人会看到什么？他们什么时候离开？

#283.	7.6	哪个是最容易匹配的第一块？你可以从这里开始吗？一旦你拼完了这个，下一个最简单的是哪个？

#284.	6.2	如果两个事件是互斥的（它们不能同时发生），你可以将它们的概率加在一起。你能找到一组互斥的事件，代表三次投篮中的两次吗？

#285.	9.2	广度优先搜索可能更好。深度优先搜索可能会在很长的路径上结束，即使最短路径实际上很短。是否可稍作改进使广度优先搜索变得更快？

#286.	8.3	二分查找有O(log n)的运行时间。你能在这个问题中应用二分查找吗？

#287.	7.12	为了处理冲突，散列表应该是一个以链表为节点的数组。

#288.	10.9	如果我们试图使用一个数组来记录它，会发生什么？这有什么优点和缺点呢？

#289.	10.8	你能用位向量吗？

#290.	8.4	任何属于{a, b}的子集都是{a, b, c}的子集。哪个集合是{a, b, c}的子集却不是{a, b}的子集。

#291.	10.9	可以使用前面的提示在行和列上向上、向下、向左和向右移动吗？

#292.	10.11	重新访问你刚才写出的{0, 1, 2}序列。想象一下有元素在最左边的元素之前。你能确保交换元素的方式不会使数组的前一部分失效吗？

#293.	9.5	你能把一个散列表和一个链表结合，来获得两全其美的结果吗？

#294.	6.8	实际上，第一次扔要稍低一些。例如，你可以在第10层扔，然后是第20层，再然后是第30层，以此类推。最坏的情况是19次（第10层, 第20层……第100层, 第91层, 第92层……第99层）。你能做得比这更好吗？不要随意猜测不同的解题方案，而是要深入思考。最坏的情况如何定义？每个鸡蛋被扔的次数是怎样被影响的？

#295.	8.9	我们可以通过计算左、右括号数保证这个字符串是有效的。添加一个左括号，直到括号的总数成对，这样字符串总是有效的。只要count(left parens) <= count(right parens)，就可以添加一个右括号。

#296.	6.4	你可以认为这是概率（3只蚂蚁走顺时针方向）+ 概率（3只蚂蚁走逆时针方向）。或者，你可以把它看作：第一只蚂蚁选择了一个方向。其他蚂蚁选择同一方向的概率是多少？

#297.	5.2	想想那些不能用二进制精确表示的值会发生什么。

#298.	10.3	你能为此改进二分查找吗？

#299.	11.1	unsigned int会发生什么？

#300.	8.11	试着把它分解成子问题。如果你在做改变，第一选择是什么？

#301.	10.10	使用数组存在的问题是插入一个数字会比较慢。我们还能使用其他的数据结构吗？

#302.	5.5	如果(n & (n - 1)) == 0，那么这意味着n和n - 1在同一个位置永远不会同时为1。为什么会这样？

#303.	10.9	另一种方法是，如果你沿着单元格画一个矩形一直延伸到底部，那么矩阵右坐标所在的单元格将大于这个矩形中所有的单元格。

#304.	9.2	有没有从起点和目的地进行搜索的方法？基于什么原因或者在什么情况下，这会更快？

#305.	8.14	如果你的代码看起来很长，有很多的if（基于每个可能的操作符、“目标”布尔结果和左/右侧），考虑不同部分之间的关系。尽量简化代码。它不需要大量复杂的if语句。例如，考虑<LEFT>OR<RIGHT>与<LEFT>AND<RIGHT>的表达式。两者可能都需要知道<LEFT>计算结果为true的数量。看看你可以重用哪些代码。

#306.	6.9	数字3有偶数个因数（1和3）。数字12有偶数个因数（1, 2, 3, 4, 6, 12）。什么数字不行？对于柜门，这告诉了你什么？

#307.	7.12	仔细考虑链表节点需要包含哪些信息。

#308.	8.12	我们知道每一行都有一个皇后。你能试试所有的可能性吗？

#309.	8.7	方法2：生成一个abcd的全排列，需要选择一个初始字符。它可以是a、b、c或d。然后你可以排列其余的字符。如何使用这种方法生成完整字符串的所有排列？

#310.	10.3	该算法的运行时间是什么？如果数组有重复，会发生什么？

#311.	9.5	你怎么把它扩大到一个更大的系统？

#312.	5.4	下一步：你能翻转0到1，创建下一个最大的数字吗？

#313.	11.4	想一想设计负载测试是为了测试什么。造成网页负载的因素有哪些？有哪些标准可用于判断一个网页在高负载下运作良好？

#314.	5.3	每个序列都可以通过与邻近的序列合并或者直接翻转紧挨着的0来增加其长度。你只需要找到最好的选择。

#315.	10.8	考虑自己实现一个位向量类。这是一个很好的练习，也是这个问题的一个重要组成部分。

#316.	10.11	你应该可以设计一个O(n) 的算法。

#317.	10.9	每个单元格的数会小于其下方和右侧的所有数，会大于其上方和左侧的所有数。如果我们想在第一轮排除最多元素，应该将x与哪个元素进行比较？

#318.	8.6	如果你在递归方面遇到困难，请尝试更多地相信递归过程。一旦弄清如何将前2个盘子从柱0移至柱2，就可以相信你完成了这项工作。当需要移动3个盘子时，请相信你可以将2个盘子从一根柱子移动到另一根柱子。现在，你已经移动了2个盘子。那么要如何处理第三个盘子呢？

#319.	6.1	想象一下只有3个瓶子，其中一瓶中有更重的药丸。假设你从每个瓶子中分别取出不同数量的药丸放在天平上（例如，从药瓶#1中取出5粒药丸，从药瓶#2中取出2粒药丸，从药瓶#3中取出9粒药丸），天平会怎样？

#320.	10.4	想想二分查找是如何工作的。只实现二分查找会有什么问题？

#321.	9.2	讨论如何在现实世界里实现这些算法和该系统。你可以做出什么样的优化？

#322.	8.13	一旦我们选择了底部的箱子，就需要选择第二个箱子，然后是第三个。

#323.	6.2	三投两中的概率为：（第1、2次投中，第3次未投中）的概率 +（第1、3次投中，第2次未投中）的概率 +（第1次未投中，第2、3次投中）的概率 +（3次全投中）的概率。

#324.	8.11	如果你正在进行换零操作，不妨从决定需要多少个币值为25分的硬币开始。

#325.	11.2	考虑一下程序以及程序以外的问题（系统的其余部分）。

#326.	9.4	预估一下这需要多少空间。

#327.	8.14	着眼于你的递归上。有重复调用吗？可以将结果存起来吗？

#328.	5.7	二进制的1010等价于十进制的10，也相当于十六进制的0xA。那么二进制的101010...在十六进制中是什么？也就是说，你要如何表示1在奇数位上的1和0交替序列？如果反过来呢（1在偶数位）？

#329.	11.3	想想极限情况和更一般的情况。

#330.	10.9 	如果将x与矩阵中的中心元素进行比较，我们可以排除大约四分之一的元素。

#331.	8.2 	为了让机器人到最后一个格子，必须找出到倒数第二个格子的路径。为了到倒数第二个格子，必须找出到倒数第三个格子的路径。

#332.	10.1 	尝试从数组的末端向前端移动。

#333.	6.8 	如果我们以固定间隔扔鸡蛋 1（例如，每 10 层），这样最坏的情况是：鸡蛋 1 的最坏情况 + 鸡蛋 2 的最坏情况。上述解法的问题在于，即使鸡蛋 1 做更多的工作，鸡蛋 2的工作也不会更少。理想情况下，我们想平衡一下。由于鸡蛋 1 做了更多的工作（从更多次扔下中幸存），因此鸡蛋 2 需要做的工作应该更少。这意味着什么？

#334.	9.3 	想想怎样会出现无限循环。

#335.	8.7 	方法 2：要生成abcd的所有排列组合，请选择每个字符（a、b、c、d）作为首字符。排列剩余的字符并追加首字符。如何排列剩余的字符？使用遵循相同逻辑的递归过程。

#336.	5.6 	你要怎样计算两个数字之间有多少位不同？

#337.	10.4 	二分查找需要比较元素与中点。获取中点需要知道长度。我们不知道长度，能找到它吗？

#338.	8.4 	包含c的子集是{a, b, c}，而非{a, b}。你能使用子集{a, b}构建这些子集吗？

#339.	5.4 	下一步：把0翻转为1将创建一个更大的数字。索引越靠右，数字越大。如果有一个1001这样的数字，那么我们就想翻转最右边的0（创建1011）。但是如果有一个1010这样的数字，我们就不应该翻转最右边的1。

#340.	8.3 	给定一个特定的索引和值，你能确定魔术索引是在它之前还是之后吗？

#341.	6.6 	现在假设有两个蓝眼睛的人。他们会看到什么？他们会知道什么？他们什么时候离开？从先前的提示想一下你的答案。假设他们知道前面提示的答案。

#342.	10.2 	你真的需要真正的排序吗？或者仅需重新组织列表就够了？

#343.	8.11 	一旦你决定用两个25分兑换98分，就需要弄清楚用5分、10分和1分兑换 48分有多少种方式。

#344.	7.5 	考虑一个在线图书阅读器系统必须支持的所有不同的功能。你不需要做任何事，但应该考虑明确你的假设。

#345.	11.4 	你能自己做吗？那会是什么样子？

#346.	5.5 	n的样子和n–1的样子有什么关系？进行二进制减法。

#347.	9.4  	你需要多次扫描吗？需要多台机器吗？

#348.	10.4 	可以通过指数式回退找到长度。首先尝试索引2，然后是4、8、16等。这个算法的运行时间是多少？

#349.	11.6 	我们可以自动化什么？

#350.	8.12 	每行都必须有个皇后。从最后一行开始。有8个不同的列你可以放皇后。你能挨个试试吗？

#351.	7.10 	数字单元格、空白单元格和炸弹单元格应该是单独的类吗？

#352.	5.3 	尝试用线性时间、单次扫描和O(1) 空间完成它。

#353.	9.3 	你如何检测相同页面？这意味着什么？

#354.	8.4 	通过把c加到所有{a, b}的子集里，你可以构建剩余的子集。

#355.	5.7 	尝试用掩码0xaaaaaaaa和0x55555555提取偶数位和奇数位。然后尝试移动偶数位和奇数位来创建正确的数字。

#356.	8.7 	方法 2：你可以通过让递归函数返回字符串列表来实现该方法，然后在它上面追加首字符。或者，你可以将前缀下推到递归调用中。

#357.	6.8 	一开始尝试以较大的间隔扔鸡蛋1，然后逐渐缩小间隔。我们的想法是尽可能保持扔鸡蛋1和扔鸡蛋2次数之和不变。每多扔一次鸡蛋1，鸡蛋2就少扔一次。正确的间隔是多少？

#358.	5.4 	下一步：我们应该翻转最右边但非拖尾的0。数字1010会变成1110。完成后，我们需要把1翻转成0让数字尽可能小，但要大于原始数字（1010）。该怎么办？如何缩小数字？

#359.	8.1 	尝试用制表法的方式优化效率低下的递归过程。

#360.	8.2 	首先明确是否有路径，以便稍微简化这个问题。然后，修改你的算法跟踪路径。

#361.	7.10 	放置炸弹的算法是什么？

#362.	11.1 	查看一下printf的参数。

#363.	7.2 	在编程之前，列一份你需要的对象清单，并过一遍常用算法。想象一下代码。你要的东西都全了吗？

#364.	8.10 	把这个看成一个图。

#365.	9.3 	如果两个页面相同，如何进行定义？是URL吗？是内容吗? 这两种都有缺陷。为什么？

#366.	5.8 	先试试简单解法。你能设置一个特定的“像素”吗？

#367.	6.3 	想象一块多米诺骨牌放在棋盘上。它盖住了多少个黑色方格？多少个白色方格？

#368.	8.13 	实现一个基本的递归算法之后，你要考虑是否可以优化它。其中有重复的子问题吗？

#369.	5.6 	想想异或表示什么。如果你把a异或b，那么结果中哪里是1？哪里是0？

#370.	6.6 	由此推导下去。如果有3个蓝眼睛的人呢？如果有4个蓝眼睛的人呢？

#371.	8.12 	把它拆分成更小的子问题。第8行的皇后必定在第1、2、3、4、5、6、7或8列。当一个皇后在第8行第3列，你能输出所有可能的八皇后位置吗？然后你需要做的就是检查将一个皇后放在第7行的所有情况。

#372.	5.5 	当做二进制减法时，你把最右边的0翻转成1，当访问到1（也要翻转）时停止。左边的一切（0和1）都会保持原样。

#373.	8.4 	你也可以将每个子集映射成二进制数。第i位可以表示元素是否在集合中的“布尔”标志。

#374.	6.8 	假设X是第一次扔鸡蛋1的层数。如果鸡蛋1破碎，则意味着鸡蛋2会被扔X – 1次。我们希望尽可能地保持鸡蛋1和鸡蛋2扔下的次数总和一致。如果鸡蛋1在第二次扔下时破碎，那么鸡蛋2需要被扔X – 2次。如果鸡蛋1在第三次扔下时破碎，那么鸡蛋2需要被扔X – 3次。这样扔鸡蛋1和鸡蛋2的次数之和恒定。X是多少？

#375.	5.4 	下一步：我们可以通过将所有的1移动到翻转位的右侧，并尽可能地向右移动来缩小数字（在这个过程中去掉一个1）。

#376.	10.10 	二叉搜索树效果好吗？

#377.	7.10 	要在网格上随机放置炸弹：想想洗牌算法。你能应用相似的技术吗？

#378.	8.13 	或者，我们可以考虑重复的选择：第一个箱子要放上去吗？第二个箱子要放上去吗？如此反复。

#379.	6.5 	如果你装满5夸脱的水壶，再用它装满3夸脱的水壶，那么5夸脱的水壶里就剩下2夸脱了。你可以把这2夸脱放在那里，也可以把小水壶里的水倒干净，然后倒入这2夸脱。

#380.	8.11 	分析你的算法。有重复性的工作吗？你能优化它吗？

#381.	5.8 	当你画一条长线时，你会得到即将变成1的序列的全部字节。你可以一次性设置它吗？

#382.	8.10 	你可以使用深度优先搜索（或广度优先搜索）。“正确”颜色的每个相邻像素都是一个连接边。

#383.	5.5 	想象n和n-1。要从n中减去1，你需要将最右边的1翻转为0，并将其右边的所有0都翻转为1。如果满足n & (n-1) == 0，那么第一个1的左边没有1。这对n意味着什么？

#384.	5.8 	那这条线的起点和终点呢？你需要单独设置这些像素，还是可以同时设置所有像素？

#385.	9.1 	把它想象成一个现实应用。你需要考虑哪些不同的因素？

#386.	7.10	如何计算一个网格周围的炸弹数量？你会遍历所有网格吗？

#387.	6.1 	你应该能得到一个会告诉你哪一个是重瓶子的基于重量的方程。

#388.	8.2 	再考虑一下你算法的效率。你能优化它吗？

#389.	7.9 	rotate()方法的运行时间应该能够达到O(1)。

#390.	5.4 	获取前一个：一旦你解决了“获取后一个”，请尝试翻转“获取前一个”的逻辑。

#391.	5.8 	当x1和x2在同一个字节中时，你的代码能否处理这种情况。

#392.	10.10 	考虑一个二叉搜索树，其中每个节点存储一些额外的数据。

#393.	11.6 	你考虑过安全性和可靠性吗？

#394.	8.11 	试试制表法。

#395.	6.8 	最坏情况我扔了14次。你的最坏情况呢？

#396.	9.1 	这里没有正确答案。讨论几种不同的技术实现。

#397.	6.3 	棋盘上有多少个黑色方格？多少个白色方格？

#398.	5.5 	我们知道如果n & (n-1) == 0，那么n必须只有一个1。什么样的数字只有一个1？

#399.	7.10 	当点击空白单元格时，展开相邻单元格的算法是什么？

#400.	6.5 	一旦你找到一个解决这个问题的方法，就可以从更具普遍意义的角度去考虑它。如果给你一个大小为X的水壶和另一个大小为Y的水壶，你能用它们来测量出Z吗？

#401.	11.3 	有可能测试所有东西吗？你会如何确认测试的优先级？

#402.	12.9 	先关注概念，然后再担心具体的实现。应该怎么看待智能指针？

#403.	15.2 	上下文切换是指在两个进程之间切换所花费的时间。当你将一个进程引入执行并置换现有进程时，就会发生这种情况。

#404.	13.1 	想想谁能访问私有方法。

#405.	15.1 	它们在内存方面有什么不同？

#406.	12.11 	回想一下，二维数组本质上就是数组的数组。

#407.	15.2 	理想情况下，我们希望记录一个进程“停止”时的时间戳和另一个进程“启动”时的时间戳。但如何知道两个进程何时会进行交换呢？

#408.	14.1 	GROUP BY子句可能有用。

#409.	13.2 	何时会执行finally代码块？有没有不执行的情况？

#410.	12.2 	我们能做到原址吗？

#411.	14.2 	将方法分成两部分可能会有所帮助。第一步是获取每个建筑物ID和状态为“Open”的申请数量。然后，我们可以得到建筑物的名称。

#412.	13.3 	考虑到其中一些可能具有不同的含义，具体取决于它们的应用位置。

#413.	12.10 	通常，malloc只会给我们一个任意的内存块。如果不能重写这个行为，我们可以用它来做我们需要的吗？

#414.	15.7 	首先实现单线程FizzBuzz问题。

#415.	15.2 	尝试设置两个进程，让它们来回地传递少量数据。这将促使系统停止一个进程并载入另一个进程。

#416.	13.4 	它们的目的可能有些相似，但实现有什么不同呢?

#417.	15.5 	怎样确保first()在调用second()之前已终止？

#418.	12.11 	一种方法是为每个数组调用malloc。我们在这里怎样释放内存？

#419.	15.3 	当一个“循环”按谁等待谁的顺序出现时，就会发生死锁。我们如何打破或阻止这种循环？

#420.	13.5 	考虑底层数据结构。

#421.	12.7 	想想为什么我们使用虚函数。

#422.	15.4 	如果每个线程都必须预先声明它可能需要的进程，我们是否可以提前检测到可能的死锁？

#423.	12.3 	每种数据背后的基础数据结构是什么？这有什么影响？

#424.	13.5 	HashMap使用链表数组。TreeMap使用红黑树。LinkedHashMap使用双向链表桶。这意味着什么？

#425.	13.4 	考虑基本数据类型的使用。在如何使用这些类型方面，它们还有什么不同之处？

#426.	12.11 	我们可以将它分配为一个连续的内存块吗？

#427.	12.8 	此数据结构可以描绘为二叉树，但不一定。如果结构中有循环怎么办？

#428.	14.7 	你可能需要学生列表，即他们的课程列表以及另一个表示学生和课程之间关系的表。请注意，这是一种多对多关系。

#429.	15.6 	关键字synchronized确保两个线程不能同时在同一个实例上执行同步方法。

#430.	13.5 	想想它们在遍历key的顺序方面可能有何不同。为什么你想要其中之一而不是其他呢？

#431.	14.3 	首先尝试获取所有相关公寓的ID列表（仅仅是ID）。

#432.	12.10 	想象一下，我们有一组连续的整数（3，4，5 …）。这个集合需要多大才能确保其中一个数字可以被16整除？

#433.	15.5 	为什么使用布尔标志是一个坏主意？

#434.	15.4 	把请求的顺序想象成一个图。在图里死锁是什么样子？

#435.	13.6 	对象反射允许访问对象中方法和字段的信息。为什么它有用？

#436.	14.6 	要特别注意哪些关系是一对一，一对多，多对多。

#437.	15.3 	一个点子是，如果哲学家拿不到另一根筷子，那一开始就不要让他拿到左手边的筷子。

#438.	12.9 	考虑追踪引用的数量，这能告诉我们什么？

#439.	15.7 	不要在单线程问题上做任何花哨的事情。只是得到简单易读的东西。

#440.	12.10 	我们如何释放内存？

#441.	15.2 	如果你的解决方案不完美也没关系。完美可能并不存在。权衡你的方法的利弊。

#442.	14.7 	选择前10% 时，仔细考虑如何处理关系。

#443.	13.8 	一个简单的方法是选择一个随机的子集大小z，然后遍历，每个元素放进集合的可能性为z/list_size。为什么这样行不通？

#444.	14.5 	反规范化意味着向表中添加冗余数据。它通常用于非常大的系统中。为什么这样有用呢？

#445.	12.5	浅复制只复制初始数据结构。深复制不仅复制初始数据结构，还复制一切基础数据。既然如此，为什么还要使用浅复制呢？

#446.	15.5	信号量有用武之地吗？

#447.	15.7 	概述线程的结构，而不必担心同步任何事情。

#448.	13.7	优先考虑一下在没有lambda表达式的情况下如何实现它。

#449.	12.1 	如果已经有文件中的行数，我们要怎么做？

#450.	13.8 	选择包含n个元素集合的所有子集列表。对于任何给定的x，一半的子集包含x，一半则不包含。

#451.	14.4 	描述INNER JOIN和OUTER JOIN。OUTER JOIN可以分为几种子类型：LEFT OUTER JOIN、RIGHT OUTER JOIN和FULL OUTER JOIN。

#452.	12.2 	小心null字符。

#453.	12.9 	我们想覆写的所有不同的方法/操作符是什么？

#454.	13.5 	常见操作的运行时间是多少？

#455.	14.5 	想想在大型系统里join操作的成本。

#456.	12.6 	关键字volatile表示一个变量可能从程序之外被改变，比如被另一个进程改变。这样为什么是必要的？

#457.	13.8 	不要预先选择子集的长度。你不需要那样做。相反，考虑一下对于每个元素，是否选择将元素放入集合中。

#458.	15.7 	等完成每个线程的结构以后，你就可以考虑需要同步什么了。

#459.	12.1 	假设我们没有文件中的行数。有没有一种方法可以在不预先计算行数的情况下做到这件事。

#460.	12.7 	如果析构函数不是虚拟的，会发生什么？

#461.	13.7 	将其分为两部分：过滤国家，然后计算和。

#462.	12.8 	考虑使用散列表。

#463.	12.4 	在这里你应该讨论虚函数表。

#464.	13.7 	你能不做filter操作吗？

#465.	16.12 	考虑递归或类似于树状结构的做法。

#466.	17.1 	手动（慢慢地）完成二进制加法，尝试真正理解发生了什么。

#467.	16.13	画一个正方形和一些把它切成两半的线。这些线位于哪里？

#468.	17.24	从蛮力解法开始。

#469.	17.14	实际上有几种方法。动脑筋想一想。从简单的方法开始也没问题。

#470.	16.20	想想递归。

#471.	16.3	所有的线都会相交吗？什么决定两条线是否相交？

#472.	16.7	如果a > b，则k为1，否则为0。如果给定k，你能返回最大值吗（没有比较或if-else逻辑）？

#473.	16.22	棘手的是处理无限网格。你有什么选择？

#474.	17.15	试着简化这个问题：如果你只需要知道由列表中其他两个单词组成的最长单词会如何？

#475.	16.10	方案 1：你能计算出每年有多少人活着吗？

#476.	17.25	首先根据单词长度对字典进行分组，因为你知道每一列的长度必须相同，每一行的长度也必须相同。

#477.	17.7	讨论一下简单方法：当它们是同义词时将名称合并到一起。你如何确定传递关系？A == B, A == C, C == D表示A == D == B == C。

#478.	16.13	任何把正方形切成两半的直线都穿过正方形的中心。那你怎么才能找到一条把两个正方形切成两半的线呢？

#479.	17.17	从蛮力解法开始。运行时间是多少？

#480.	16.22	选项1：你真的需要一个无线的网络吗？再次审题。你知道网格的最大尺寸吗？

#481.	16.16	在开始和结束时知道最长的排序序列会有帮助吗？

#482.	17.2	尝试递归地解决这个问题。

#483.	17.26	解法1：从一个简单的算法开始，将每个文档依次与其他文档进行比较。你如何尽快计算两个文档的相似度？

#484.	17.5	是哪个字母或数字并不重要。你可以把该问题简化为只包含A和B的数组。然后寻找具有相同数量的A和B的最长子数组。

#485.	17.11	如果只运行一次算法，请首先考虑寻找最近距离的算法。你应该能够在O(N)时间内完成这项工作，其中N是文档中的字数。

#486.	16.20	你能递归地尝试所有的可能性吗？

#487.	17.9	明确这个问题的要求。要求满足3a× 5b× 7c这一形式的第k小的值。

#488.	16.2	想想这个问题的最佳运行时间是多少。如果你的解法匹配最理想的运行时间，那么你可能无法做的更好了。

#489.	16.10	方案1：用散列表或数组试试，将出生年份映射到该年还有多少人活着。

#490.	16.14	有时，蛮力解法是相当好的办法。你能试试所有可能的直线吗？

#491.	16.1	尝试在数轴上画出a和b两个数字。

#492.	17.7	该问题的核心是将名字分组成不同的拼写。基于此，计算出频率就相对容易了。

#493.	17.3	如果你实在解不出来，那么先解决17.2吧。

#494.	17.16	此题有递归和遍历两种解法，但从递归开始可能更容易一些。

#495.	17.13	试试递归方法。

#496.	16.3	无限长的线几乎总会相交，除非它们相互平行。平行线也仍然有可能“相交”——如果它们是同一条线。这对线段来说意味着什么？

#497.	17.26	解法1：要计算两个文档的相似性，可以尝试用某种方式重新组织数据。排序？使用其他的数据结构？

#498.	17.15	如果只想知道由列表中其他两个单词组成的最长单词，那么可以遍历全部单词，从最长到最短，检查每个单词是否可以由其他两个单词组成。为了检查，我们可以将字符串从所有可能的位置分开。

#499.	17.25	你能找到一个特定长宽的单词矩阵吗？如果尝试了所有的选项会怎样？

#500.	17.11	调整你的算法，使它成为可以重复调用的算法的一次执行。它哪里慢？你能优化它吗？

#501.	16.8	试着从三位作为一段的角度思考。

#502.	17.19	从第一部分开始：如果只缺少一个数字，那么找到它。

#503.	17.16	递归解法：每个预约都有两个选择（接受预约或拒绝预约）。作为一种蛮力方法，你可以在所有可能性的地方递归。但是请注意，如果接收了预约请求i，那么你的递归算法应该跳过预约请求i + 1。

#504.	16.23	需要特别注意的是，你的解法实际上概率地返回0到6之间的每个数。

#505.	17.22	从一个蛮力的递归解法开始。只需要创建所有一次编辑的单词，检查它们是否在字典中，然后尝试该编辑路径。

#506.	16.10	解法2：如果对年份排序会如何？你会根据什么排序？

#507.	17.9	蛮力解法得到的形如3a× 5b × 7c的第k小的值是什么样的？

#508.	17.12	尝试递归解法。

#509.	17.26	解法1：你应该能够得到一个O(A+B) 的算法来计算两个文档的相似性。

#510.	17.24	蛮力解法要求连续计算每个矩阵的和。能优化它吗？

#511.	17.7	你要尝试的一件事是维护每个名称到其“真正”拼写的映射。你还需要从真正的拼写映射到所有同义词。有时，你可能要合并两组不同的名称。运行一下这个算法，看看你能否让它工作。然后看看是否能简化/优化它。

#512.	16.7	如果当a > b时，k等于1，那么当k等于0时则相反，然后你可以返回a*k + b* (非k)。但你如何创建k？

#513.	16.10	解法2：你真的有必要匹配出生年份和死亡年份吗？当一个特定的人死了，会有什么关系，或者你只是需要一份死亡年份的清单？

#514.	17.5 	从蛮力解法开始。

#515.	17.16 	递归解法：你可以通过制表法优化这种方法。这种方法的运行时间是多少？

#516.	16.3 	我们怎样才能找到两条线的交点。如果两条线相交，那么交点必须与它们的“无限”延伸处于同一点。这两条线之间是交点吗？

#517.	17.26 	解法1：交集和并集之间是什么关系？你能用一个计算出另一个吗？

#518.	17.20 	回想一下，中位数是指比一半数字更大、一半数字更小的数字。

#519.	16.14 	你不能真的试遍世界上所有可能的无限长的线。但你知道一条“最好”的线必须至少相交两点。你能连接每对点吗？你可以检查每一条线是否是最优的吗？

#520.	16.26 	我们可以从左到右处理表达式吗？为什么会失败？

#521.	17.10 	从蛮力解法开始。你能检查一下每个值是否为主要元素吗？

#522.	16.10 	解法2：观察到人是“可替代的”，不管谁出生，何时死亡。你需要的只是一份出生年份和死亡年份的列表。这可能会使你对人员列表的排序变得更加容易。

#523.	16.25 	首先明确问题。你到底想要什么功能？

#524.	17.24 	你能做任何形式的预计算来使计算子矩阵和的运行时间为O(1)吗？

#525.	17.16 	递归解法：记忆法的时间复杂度为O(N)，空间复杂度也为O(N)。

#526.	16.3 	仔细考虑如何处理线段具有相同斜率和与y轴相交的情况。

#527.	16.13 	要将两个正方形切成两半，这条线必须穿过这两个正方形的中心。

#528.	16.14 	你应该能得到O(N²)的解法。

#529.	17.14 	考虑以某种方式重新组织数据或者使用其他数据结构。

#530.	16.17 	把数字想象成正负交替的数字序列。注意，我们永远不会只包含一个正序列的一部分或者一个负序列的一部分。

#531.	16.10 	解法2：尝试创建一份排序的出生列表和一份排序的死亡列表。通过遍历两个列表，你能追踪任意时间活着的人的数量吗？

#532.	16.22 	选项 2：想想ArrayList的工作原理。它能派上用场吗？

#533.	17.26 	解法1：要理解两个集合的交集和并集的关系，考虑用Venn图（一个圆与另一个圆重叠的图）。

#534.	17.22 	一旦你有了一个蛮力解法，就可以尝试找到一个更快的方法以得到所有一次编辑的有效单词。当绝大多数字符串都不是有效的字典单词时，你不会想创建所有一次编辑的字符串。

#535.	16.2 	可以使用散列表来优化重复的情况吗？

#536.	17.7 	使用上述方法的一种简单方式是将每个名称映射到一个备选拼写列表。当一个组中的一个名称设置为等于另一个组中的名称时会发生什么？

#537.	17.11 	你可以构建一个查找表，把每个单词映射到它出现位置的列表。然后怎样找到最近的两个位置呢？

#538.	17.24 	如果你预先计算从左上角开始并扩展到全部单元格的子矩阵的和会怎样？计算它需要多长时间？计算完以后，你能在O(1)时间内得到任意子矩阵的和吗？

#539.	16.22 	选项2：使用ArrayList是不可能的，因为那样太烦琐了。也许构建自己的列表会更容易，但要专门针对矩阵。

#540.	16.10 	每个出生增加一个人，每个死亡移除一个人。尝试编写一份人员列表（出生年份和死亡年份）示例，然后将其重新格式化为每年的列表，出生时加1，死亡时减1。

#541.	17.16 	迭代法：对递归法进一步研究。你可以迭代地实现类似的策略吗？

#542.	17.15 	将前面的想法扩展到多个单词的情况。我们能不能把每个单词都拆分为所有可能的形式?

#543.	17.1 	你可以把二进制加法看成是对数字的每一位进行迭代、两位进行加和，并在必要时进位。你也可以对操作进行分组。如果首先对每位相加（不进位）会怎样？之后，你可以再处理进位。

#544.	16.21 	在这里用一些例子做些数学计算。这一对数值有什么需求？你发现它们的值有什么特点？

#545.	17.20 	注意，必须存储见过的所有元素。即使是前100个元素中最小的元素也可以成为中间值。你不能抛弃较大或较小的元素。

#546.	17.26 	解法2：人们很容易想到一些小的优化——例如，在每个数组中跟踪最小和最大元素。然后，在特定情况下，你可以快速计算出两个数组是否不重叠。这样做（以及其他类似的优化）的问题是，仍然需要将所有文档与其他文档进行比较。它没有利用相似度是“稀疏”的这一事实。考虑到我们有很多文档，真的不需要将所有文档与其他文档进行比较（即使比较运算速度很快）。所有这类解复杂度都是O(D²)，其中D是文档的编号。我们不应该将所有的文档与其他文档进行比较。

#547.	16.24 	从蛮力解法开始。运行复杂度是什么？解决这个问题的最佳时间是什么？

#548.	16.10 	解法3：如果你创建了一个年份数组并保存每个年份的人口变化会如何？你能找到人口最多的那一年吗?

#549.	17.9 	在寻找3a× 5b× 7c的第k个最小值时，我们知道a、b、c将小于等于k。你能生成所有可能的数字吗?

#550.	16.17 	注意，如果你有一个和是负数的数列，那么其一定不是一个数列的开始或结束（如果它们连接了另外两个数列，那么就可以以一个数列的形式出现）。

#551.	17.14 	你能把这些数字排序吗?

#552.	16.16	我们可以把这个数组分成3个子数组：LEFT、MIDDLE和RIGHT。LEFT和RIGHT都是有序的。MIDDLE的元素顺序是任意的。我们需要展开MIDDLE，直到可以对这些元素排序并使整个数组有序。

#553.	17.16 	迭代法：从数组的末尾开始，然后向后计算可能是最简单的。

#554.	17.26 	解法2：如果我们不能将所有文档与其他文档进行比较，那么就需要进一步比较其元素。考虑一个简单的解决方案，看看是否可以将其扩展到多个文档。

#555.	17.22 	为了快速得到编辑距离为1的有效单词，试着将字典中的单词以一种有效的方式进行分组。注意，b_ll形式的所有单词（如bill、ball、bell和bull）的编辑距离为1。然而，这些并不是仅有的编辑距离为1的单词。

#556.	16.21 	当你把一个值a从数组A移动到数组B时，A的和减少了a, B的和增加了a。当你交换两个值时会发生什么？交换两个值并得到相同的和需要什么？

#557.	17.11 	如果你有一个每个单词出现次数的列表，那么你实际上需要在两个数组中寻找一对值（每个数组中选一个值），使它们之间的差异最小。这应该是一个与初始算法很相似的算法。

#558.	16.22 	方法2：一种方法是当蚂蚁到达边缘时，将数组的大小加倍。但是，你将如何处理蚂蚁到达负坐标的问题呢？数组不能有负的索引。

#559.	16.13 	给定一条直线（斜率和y轴截距），你能找到它与另一条直线的交点吗?

#560.	17.26 	解法2：思考这个问题的一种方法是，我们需要能够非常快速地找到与特定文档有某一相似值的所有文档的列表（同样地，我们不应该“查看所有文档并快速消除不具备某相似值的文档”。那样的话时间复杂度至少是O(D²)）。

#561.	17.16 	迭代法：注意，你永远不会连续跳过3个预约。为什么不会？因为你总是可以接受中间的预约。

#562.	16.14 	你试过使用散列表吗?

#563.	16.21 	如果你交换两个值，即a和b，那么A的和变成sumA - a + b，而B的和变成sumB - b + a。这两个和需要相等。



#564.	17.24 	如果你能预先计算从左上角到每个单元格的和，那么便可以在O(1)时间内用它来计算任意子矩阵的和。画一个特定的子矩阵。这个子矩阵上面的数组（C）、左边的数组（B），以及上边和左边的数组（A）的和均分别预先计算完成。你如何计算D的和？



#565.	17.10	考虑蛮力解法。我们选择一个元素，然后通过计算匹配和非匹配元素的数量来验证它是否是主要元素。假设对于第一个元素，前几次检查显示7个不匹配的元素和3个匹配的元素。有必要继续检查这个元素吗?

#566.	16.17 	从数组的开头开始。当这个子数列增长时，它仍然是最佳子数列。然而，一旦变成负数，它就没有意义了。

#567.	17.16 	迭代法：如果你选择i，那么将永远不会选择i + 1，但是总会选择i + 2或i + 3。

#568.	17.26 	解法2：根据前面的提示，我们可以思考是什么构成了与特定文档（类似于{13, 16, 21, 3}文档）有指定相似度的文档。这个列表有哪些属性？我们如何收集所有的那样的文档？

#569.	16.22 	选项2：注意，问题中没有规定坐标的标签必须保持不变。你能把蚂蚁和所有的单元格信息移动到正坐标吗？换句话说，如果当你需要让数组n向负方向增长时，你重新标记了所有的指标使它们仍然是正的，会发生什么?

#570.	16.21 	你在寻找a和b的值，其中sumA - a + b = sumB - b + a。用数学方法算出这对a和b的值意味着什么。

#571.	16.9 	从减法开始，逐步解决。一旦完成了一个函数，你可以用它来实现其他函数。

#572.	17.6 	从蛮力解法开始。

#573.	16.23 	从蛮力解法开始。在最坏的情况下，需要调用多少次rand5() ?

#574.	17.20 	另一种思考方法是：你能维护元素的下半部分和上半部分吗?

#575.	16.10 	解法3：注意这个问题中的细节。你的算法/代码是否考虑一个在出生的同一年去世的人？这个人应该被计算为人口总数中的一人。

#576.	17.26 	解法2：与{13, 16, 21, 3}相似的文档列表包括所有包含3、16、21和3的文档。如何才能有效地找到这个列表？记住，我们将对许多文档做此计算，所以一些预处理是必要的。

#577.	17.16 	迭代法：使用一个例子并从后往前计算。你可以很容易地找到子数组{rn}、{rn-1, rn}和{rn-2, ..., rn}。如何使用这些结果快速找到{rn-3, ..., rn}的最优解？

#578.	17.2 	假设你有一个方法shuffle，它可以处理最多n – 1个元素。你能用这个方法来实现一个新的shuffle方法使其处理最多n个元素吗?

#579.	17.22 	创建从通配符形式（如b_ll）到该通配符所匹配的所有单词的映射。然后，当你想要查找与bill相隔编辑距离为1的所有单词时，可以在映射中查找_ill、b_ll、bi_l和bil_。

#580.	17.24 	D的和将是sum(A&B&C&D) - sum(A&B) - sum(A&C) + sum(A)。

#581.	17.17	你能用trie吗?

#582.	16.21 	如果计算一下，那我们要找一对这样的值，即a - b = (sumA - sumB) / 2。然后，问题归结为寻找具有特定差的一对值。

#583.	17.26 	解法2：尝试构建一个散列表，使其从每个单词映射到包含此单词的文档。这将允许我们轻松地找到所有与{13, 16, 21, 3}有特定相似值的文档。

#584.	16.5 	0如何变成n!？这是什么意思？

#585.	17.7 	如果每个名称都映射到其替代拼写的列表，那么在将X和Y设置为同义词时，你可能需要更新许多列表。如果X是{A, B, C}的同义词，而Y是{D, E, F}的同义词，那么你需要将{Y, D, E, F}添加到A的同义词列表、B的同义词列表、C的同义词列表和X的同义词列表中。{Y, D, E, F}同理。有更快的方法么?

#586.	17.16 	迭代法：如果你预约某一时间段，那就不能预约紧邻的下一时间段，但可以预约之后的任何时间。因此，optimal(ri, ..., rn) = max(ri + optimal(ri+2, ..., rn)，optimal(ri+1, ..., rn))。你可以通过从后往前迭代来解决这个问题。

#587.	16.8 	你考虑过负数吗？你的解决方案是否适用于100 030 000这样的值？

#588.	17.15 	当你得到非常低效的递归算法时，试着查找重复发生的子问题。

#589.	17.19 	第1部分：如果你必须在O(1)的空间复杂度和O(N)的时间复杂度下找到丢失的数字，那么只能在数组中执行常数次遍历，并且只能存储少许变量。

#590.	17.9 	查看3a×5b×7c对应的所有值的列表，可以观察到列表中的每个值都是3×（列表中前面的某值）、5×（列表中前面的某值）或7×（列表中前面的某值）。

#591.	16.21 	一种蛮力解法是遍历所有的数值对，以找到一个具有正确差值的数值对。这可能看起来为：对A进行外循环，对B进行内循环。对于每个值，计算差值并与目标差值进行比较。能说得更具体些吗？给定A中的值和目标差，可以知道要找的B中的元素的确切值吗?

#592.	17.14 	使用堆或某种树怎么样?

#593.	16.17 	如果跟踪计算中的和，那就应该在子数列为负时立即重置它。我们永远不会在另一个子数列的开头或结尾添加一个和为负数的数列。

#594.	17.24 	通过预计算，你应该能够得到O(N4)的时间复杂度。可以更快些吗?

#595.	17.3 	试试递归解法。假设你有一种算法能从n – 1个元素中得到一个大小为m的子集。你能开发出一种算法从n个元素中得到大小为m的子集吗?

#596.	16.24 	我们可以用散列表使它更快吗?

#597.	17.22 	你之前的算法可能类似于深度优先搜索。你能使它更快吗?

#598.	16.22 	选项3：另一件需要考虑的事情是，你是否真的需要一个网格来实现它。在这个问题中你真正需要什么信息?

#599.	16.9 	减法：取负函数（将正整数转换为负数）有用吗？你可以使用加法操作符来实现吗?

#600.	17.1 	只关注上面的一个步骤。如果你“忘记”进位，那么加法操作会是什么样子?

#601.	16.21 	蛮力解法其实是在B中寻找一个等于a - target的值。你如何能更快地找到这个元素？什么方法可以帮助我们快速找到数组中是否存在某个元素?

#602.	17.26 	解法2：一旦有了一种方法可以容易地找到与特定文档有某一相似值的所有文档，你就可以通过一个简单的算法进行计算。你能让算法更快一些吗？具体来说，可以直接从散列表计算相似度吗？

#603.	17.10 	主要元素一开始看起来并不一定像主要元素。例如，有可能主要元素出现在数组的第一个元素中，然后在接下来的8个元素中都不再出现。但是，在这些情况下，主要元素将在数组的后面出现（实际上，在数组的后面会出现很多次）。当某个元素看起来“不太像”主要元素时，继续检查它并不一定很重要。

#604.	17.7 	相反，X、A、B和C应该映射到同一个集合{X, A, B, C}。Y、D、E和F应该映射到同一个集合{Y, D, E, F}。当我们将X和Y设置为同义词时，可以将其中一个集合复制到另一个集合中（例如，将{Y, D, E, F}添加到{X, A, B, C}中）。散列表还需进行其他更改么?

#605.	16.21 	可以用散列表，也可以尝试排序。两者都能帮助我们更快地定位元素。

#606.	17.16 	迭代解法：如果你仔细考虑真正需要的数据，应该能够在O(n)时间复杂度和O(1)额外空间复杂度内解出它。

#607.	17.12 	这样想：如果你有convertLeft和convertRight方法（它们可以把左右子树转换成双链表），你能使用它们把整个树转换成双链表吗？

#608.	17.19 	第1部分：如果将数组中的所有值相加会怎么样？然后你能算出缺失的数字吗？

#609.	17.4 	你需要多长时间才能算出缺失数字的最小有效位？

#610.	17.26	解法2：假设你正在通过查找一个从单词映射到文档的散列表来查找与{1, 4, 6}相似的文档。执行此查找时，同一文档ID会出现多次。这说明了什么？

#611.	17.6 	不要计算每一个数中有多少个2，要一位数一位数地想，也就是说，首先计算（对于每个数字）第1位中有多少个2，然后计算（对于每个数字）第2位中有多少个2，再计算（对于每个数字）第3位中有多少个2，以此类推。

#612.	16.9 	乘法：用加法很容易实现乘法运算，但是如何处理负数呢?

#613.	16.17 	你可以在O(N)时间复杂度和O(1)空间复杂度内解决此问题。

#614.	17.24 	假设这只是一个数组。如何计算有最大和的子数组呢？详见16.17。

#615.	16.22 	选项3：你实际上需要的是来查看一个单元格是白色的还是黑色的某种方式（当然还有蚂蚁的位置）。你能把所有的白色方格存在一个链表中吗?

#616.	17.17	一种解决方案是将较大字符串的每个后缀都插入trie。例如，如果单词是dogs，那么后缀应该是dogs、ogs、gs和s。这将如何帮助你解决该问题？其运行时间是多少？

#617.	17.22	广度优先的搜索通常比深度优先的搜索要快。在最坏的情况下未必如此，但在很多情况下都是这样。为什么？你能找到更快的方法吗？

#618.	17.5	如果你从一开始就计算A的个数和B的个数会怎样（试着构建数组构成的表并保存到目前为止A和B的数量）？

#619.	17.10	还要注意，主要元素对于某些子数组也必须是主要元素，而且子数组不能拥有多个主要元素。

#620.	17.24	假设我只是想让你找出从第r1行开始到第r2行结束的最大子矩阵，怎么才能最有效地做到这一点（参见前面的提示）？如果我现在让你找出从r1到(r2+2)的最大子数组，你能有效地做到吗?

#621.	17.9	由于每个数字都是列表中先前值的3倍、5倍或7倍，因此我们可以检查所有可能的值，然后选择下一个还没有看到的值。这将导致许多重复的工作。如何才能避免这种情况呢？

#622.	17.13	你能把所有的可能性都试一试吗？那会是什么样子？

#623.	16.26	乘法和除法是优先级较高的运算。在3*4 + 5*9/2 + 3这样的表达式中，乘法和除法部分需要组合在一起。

#624.	17.14	如果你选了一个任意的元素，那么需要多长时间才能算出它的元素的排序（比它大或比它小的元素的个数）?

#625.	17.19	第2部分：我们现在正在寻找两个缺失的数字，可以称其为a和b。第1部分中的计算方法将告诉我们a和b的和，但它实际上不会告诉我们a和b。还需要做什么计算？

#626.	16.22	选项3：你可以考虑维护一个所有白色方格的散列集合。不过，你怎么才能打印出整个网格呢?

#627.	17.1	仅相加步骤就可以做如下转化：1 + 1 -> 0，1 + 0 -> 1，0 + 1 -> 1，0 + 0 -> 0。没有+号要怎么做?

#628.	17.21	直方图中最高的长方形起什么作用?

#629.	16.25	什么数据结构对查找最有用？维护元素顺序最有用的数据结构是什么？

#630.	16.18	从蛮力解法开始。你能试一下a和b的所有可能性吗?

#631.	16.6	如果你对数组排序呢?

#632.	17.11	能用两个指针遍历两个数组吗？你应该能在O(A+B)时间内完成，其中A和B是两个数组的大小。

#633.	17.2	你可以递归地建立这个算法，把第n个元素换成它之前的任何一个元素。迭代解法会是什么样子?

#634.	16.21	如果A的和是11，B的和是8呢？能有一对数刚好有目标差吗？检查你的解决方案是否恰当地处理了这种情况。

#635.	17.26	解法3：有另一种解决方案。考虑从所有的文档中提取所有的单词，将它们放入一个巨大的列表中，并对这个列表进行排序。假设你仍然知道每个单词来自哪个文档。如何跟踪相似的文档?

#636.	16.23	制作一个表格用于表示rand5()的每个可能的调用序列如何映射为rand7()的结果。如果你使用(rand2() + rand2()) % 3实现rand3()，那么表格将如下所示。分析这个表格。它能告诉你什么?

#637.	17.8	这个问题要求我们找出可以构建的最长的序列对，使其每个序列都在不断增长。如果你只需要一个元素不断增长呢?

#638.	16.15	首先尝试创建一个具有每个元素发生频率的数组。

#639.	17.21	想象一下最高的长方形、左边第二高的长方形和右边第二高的长方形。水会填满它们之间的区域。你能计算出其面积吗？其余的面积怎么办？

#640.	17.6	是否有一种更快的方法来计算某一特定位在一个数值范围内有多少个2？注意，任何位的大约1/10应该是2，但这只是大概比例。如何将其表述得更准确些?

#641.	17.1	可以使用XOR执行加法步骤。

#642.	16.18	观察其中一个子字符串，a或b都可以，必须从字符串的开头开始。这减少了可能性的种类。

#643.	16.24	如果数组有序呢？

#644.	17.18	从蛮力解法开始。

#645.	17.12	一旦你对递归算法有了一个基本的概念，就可能会陷入这种情况：有时你的递归算法需要返回链表的头部，有时它需要返回链表的尾部。解决这个问题有多种方法，想想不同的方法。

#646.	17.14	如果你选择一个任意的元素，平均来说，就会得到一个在第50百分位数附近的元素（一半的元素比它大，一半的元素比它小）。如果反复这样做呢?

#647.	16.9	除法：如果你想计算x = a / b，请记住a = bx。你能找出x的最近值吗？记住这是整数除法，x应该是一个整数。

#648.	17.19	第2部分：有很多不同的计算方法可以试一试。例如，可以把所有的数都相乘，但这只会得到a和b的乘积。

#649.	17.10	试试这个：给定一个元素，开始检查它是否是一个子数组的开始，同时对于这个子数组，该元素是它的主要元素。一旦它变得“不太可能”（出现的次数少于一半），就开始检查下一个元素（子数组之后的元素）。

#650.	17.21	为了计算出整体上最高的长方形和左侧最高的长方形之间的面积，你只需遍历直方图并减去这两个长方形之间的任何长方形的面积。你可以在右侧做同样的事情。如何处理剩下的图表?

#651.	17.18	一种蛮力解决方案是对于每个起始位置不断向前移动，直到你找到一个包含所有目标字符的子序列为止。

#652.	16.18	不要忘记处理pattern中的第一个字符是b的可能性。

#653.	16.20	在现实世界中，我们应该知道一些前缀/子字符串是行不通的。例如，考虑数字33835676368。虽然3383确实对应于fftf，但是没有以fftf开头的单词。有没有什么办法对于这样的情况做特殊处理？

#654.	17.7	另一种方法是把它看作一幅图。应该怎么做？

#655.	17.13	你可以用两种方法中的一种来考虑递归算法：(1)对于每个字符，我应该在这里放一个空格吗？(2)下一个空格应该放在哪里？两种方案都可以递归地解决。

#656.	17.8	如果你只需要序列对中的一个元素为递增序列，那么只对该序列排序就好了。你的最长序列实际上是所有序列对（而不是重复的序列，因为最长序列是需要严格递增的）。对于最初的问题，这说明了什么？

#657.	17.21	你可以通过重复这个过程来处理图的其余部分：找到最高的长方形和第二高的长方形，然后减去它们之间的长方形的面积。

#658.	17.4	要找到缺失的数字中的最小有效位，你其实知道有多少个0和1。例如，如果你看到最小有效位有3个0和3个1，那么缺失的数字的最小值必定是1。想想看：在任何0和1的序列中，你会得到0，然后是1，然后又是0，然后又是1，以此类推。

#659.	17.9	不要检查列表中的所有值来寻找下一个值（通过将每个值乘以3、5、7），而是这样考虑：当你将一个值x插入列表时，可以“构造”3x、5x和7x以供以后使用。

#660.	17.14	回想一下前面的提示，特别是与快速排序相关的提示。

#661.	17.21	怎样才能更快地找到两边的下一个最高的长方形?

#662.	16.18	谨慎地选择分析时间复杂度的方式。如果遍历O(n2)个子字符串，每个子字符串都进行O(n)次的字符串比较，那么总体运行时间为O(n3)。

#663.	17.1	现在关注进位。在什么情况下两个值会进位？如何使用进位？

#664.	16.26	把它想成当你遇到乘法或除法时，跳至一个单独的“进程”来计算该结果。

#665.	17.8	如果你根据高度对值进行排序，那么这将告诉你最后序列对的排序。最长序列必定符合这个相对顺序（但不一定包含所有的序列对）。现在只需要找到权重尺度上的最长递增子序列，并保持这些项的相对顺序不变。这本质上与下面的问题相同：对于一个整数数组找到最长的序列（不重新排序）。

#666.	16.16	考虑3个子数组：LEFT、MIDDLE和RIGHT。只关注这个问题：是否可以排序MIDDLE以使整个数组有序？如何进行验证？

#667.	16.23	再次查看这个表，注意行数为5k，其中k是对rand5()的最大调用次数。为了使0到6之间的每个值具有相等的概率，必须将行数的1/7映射到0，1/7映射到1，以此类推。这有可能吗?

#668.	17.18	另一种对蛮力方法的考虑是，我们取每个起始索引，在目标字符串中寻找每个元素的下一个出现位置。所有这些出现位置的最大值标志着子序列的尾部（该子序列包含所有目标字符）。这个算法的时间复杂度是多少？怎样才能使它更快呢？

#669.	16.6	考虑如何合并两个有序数组。

#670.	17.5	当表中A和B的个数相等时，整个子数组（从索引0开始）的A和B的个数相等。如何使用该表来查找不以索引0开始的、符合条件的子数组？

#671.	17.19	第2部分：把数字加在一起会得到a + b的结果。把数字相乘会得到a × b的结果。怎样才能得到a和b的确切值？

#672.	16.24	如果我们对数组进行排序，那么就可以对数字进行重复的二进制搜索。如果数组是有序的呢？我们能否在O(N)时间和O(1)空间中求解这个问题？

#673.	16.19	如果给你一个指代水的单元格的行和列，你如何找到所有相邻的水域？

#674.	17.7	可以把将X, Y记为同义词看作是在X节点和Y节点之间添加一条边。那么如何计算一组同义词有哪些呢？

#675.	17.21	你能通过预计算来得出每边下一个最高的长方形是哪个么？

#676.	17.13	递归算法是否会反复遇到相同的子问题？你能用一个散列表进行优化吗？

#677.	17.14	如果当你选择一个元素时，你交换周围的元素（就像在快速排序中所做的那样），使它所有下方的元素都位于上方的元素之前，那会怎么样？如果你重复做这个，能找到最小的一百万个数吗？

#678.	16.6	假设你把两个数组排序，然后遍历它们。如果第一个数组中的指针指向3，第二个数组中的指针指向9，那么移动第二个指针会对这一对数字的差产生什么影响?

#679.	17.12	要处理递归算法是返回链表的头节点还是尾节点，可以尝试传递一个参数作为标志。但这不会很好。问题是，当调用convert(current.left)时，你希望得到left链表的尾节点。这样就可以将链表的末尾与current连接。但是，如果current是其他节点的右子树，那么convert(current)需要返回链表的头节点（其实是current.left的头节点）。实际上，链表的头节点和尾节点你都需要。

#680.	17.18	考虑一下前面解释的蛮力解法。瓶颈在于我们反复查询某个特定字符的下一个出现位置。有办法优化该过程么？你应该能在O(1)时间内完成。

#681.	17.8	尝试用递归方法来评估所有的可能性。

#682.	17.4	一旦确定最小有效位是0（或1），就可以排除所有不以0作为最小有效位的数。这个问题和前面的有什么不同?

#683.	17.23	从蛮力解法开始。你能先试试最大的正方形吗?

#684.	16.18	假设你确定了一个模式中“a”部分的值。b有多少种可能性?

#685.	17.9	当你将x添加到前k个值的列表中时，可以将3x、5x和7x添加到新的列表中。如何使其尽可能地优化？保留多个队列如何？总是需要插入3x、5x和7x吗？或者，有时你只需要插入7x？你需要避免相同的数字出现两次。

#686.	16.19	尝试递归计算含水单元格的数目。

#687.	16.8	考虑把一个数字分成由3位数组成的序列。

#688.	17.19	第2部分：我们可以两者都计算。如果知道a + b = 87，a×b = 962，那么就解出a和b : a = 13且b = 74。但这也将导致必须对非常大的数相乘。所有数的乘积可以大于10157。还有更简单的计算方法吗？

#689.	16.11	考虑制作一个跳水板。你的选择是什么？

#690.	17.18	你能从每个索引中预先计算一个特定字符的出现位置吗？尝试使用一个多维数组。

#691.	17.1	进位在1 + 1时发生。如何将进位应用到数值中？

#692.	17.21	作为另一种解决方案，请从每个长方形的角度来考虑。每个长方形上面都有水。每个长方形上面会有多少水？

#693.	16.25	散列表和双向链表都很有用。你能把这两者结合起来吗？

#694.	17.23	最大的正方形是N×N。所以你先试一下该正方形，如果可行，那么你便知道已经找到了最佳正方形。否则，可以尝试下一个最小的正方形。

#695.	17.19	第2部分：几乎任何我们能想到的“方程”都可以用在这里（只要它和线性和不等价）。只要保持这个和很小就可以。

#696.	16.23	把5k除以7是不可能的。这是否意味着你不能使用rand5()实现rand7()？

#697.	16.26	你还可以维护两个栈，一个用于操作符，另一个用于数字。每次看到一个数字，就把它压入栈。那么操作符呢？什么时候从栈中取出操作符并将它们与数字进行计算？

#698.	17.8	另一种思考这个问题的方法是：如果有结束于A[0]到A[n-1]每个元素的最长序列，你能用它来找出结束于元素A[n]的最长序列吗？

#699.	16.11	考虑递归解法。

#700.	17.12	许多人在这一点上左右为难，不知道该怎么办。有时他们需要链表的头部，有时他们需要链表的尾部。给定的节点通常不知道它在convert调用中应返回什么。有时候，最简单的解决方案就是：总是同时返回这两个值。有什么方法可以做到这一点？

#701.	17.19	第2部分：试着求所有值的平方的和。

#702.	16.20	trie可以帮助我们。如果将整个单词列表存储在trie中会怎样？

#703.	17.7	每个连通子图表示一组同义词。要找到每个组，可以重复广度优先（或深度优先）搜索。

#704.	17.23	描述蛮力解法的时间复杂度。

#705.	16.19	你如何确保不会再次访问相同的单元格？考虑一下图上的广度优先搜索或深度优先搜索是如何工作的。

#706.	16.7	当a > b时，a – b > 0。你能得到a – b的符号位吗？

#707.	16.16	为了能够对MIDDLE进行排序并对整个数组进行排序，需要MAX(LEFT) <= MIN(MIDDLE, RIGHT)和MAX(LEFT, MIDDLE) <= MIN(RIGHT)。

#708.	17.20	如果使用堆呢？或是两个堆？

#709.	16.4	如果多次调用hasWon，你的解决方案可能会发生什么变化？

#710.	16.5	n!中的每个0表示n能被10整除一次。这是什么意思？

#711.	17.1	可以用AND运算来计算进位。如何使用它？

#712.	17.5	假设在这个表中，索引i满足count(A, 0->i) = 3和count(B, 0->i) = 7。这意味着B比A多4个。如果你发现后面的某点j具有相同的差值（count(B, 0->j) - count(a, 0->j)），那么这表示子数组中有相同数量的A和B。

#713.	17.23	你能通过预处理来优化这个解决方案吗？

#714.	16.11	一旦有了递归算法，就考虑一下时间复杂度。能快点吗？如何进行？

#715.	16.1	定义diff为a和b之间的差。你能以某种方式使用diff吗？那么你能去掉这个临时变量吗？

#716.	17.19	第2部分：你可能需要二次公式。如果你不记得也没什么大不了的，大多数人都不会记得。知道二次公式的存在即可。

#717.	16.18	由于a的值决定b的值（反之亦然），并且a或b必须出现于值的起始处，所以你应该只有O(n)种可能来分解模式串。

#718.	17.12	可以通过多种方式返回链表的头部和尾部。可以返回一个双元素数组，可以定义一个新的数据结构来保存头节点和尾节点，还可以重用BiNode数据结构。如果你使用的语言（如Python）支持返回多个值，你就可以使用此功能。可以将这个问题作为一个循环链表来解决，即头节点的前一个指针指向尾部，然后在外部的函数中拆开循环链表。试试这些解决方案。你最喜欢哪个？为什么？

#719.	16.23	可以用rand5()来实现rand7()，只是你不能有效地确定其执行次数（即你知道在一定数量的调用之后它肯定会终止）。考虑到这一点，写下一个可行的解决方案。

#720.	17.23 	你应该能在O(N3)时间内完成，其中N是正方形一边的长度。

#721.	16.11	 考虑使用缓存来优化时间复杂度。仔细想想你到底需要缓存什么。时间复杂度是什么？时间复杂度与表的最大尺寸密切相关。

#722.	16.19 	你应该有一个算法，其在N×N矩阵上的时间复杂度是O(N2)。如果你的算法并非如此，请考虑是否错误地计算了时间复杂度，或者是否你的算法不是最优的。

#723.	17.1 	你可能需要不止一次地执行加法/进位操作。将进位加到和中可能会产生新的进位值。

#724.	17.18 	在得到了预计算的解法之后，考虑一下如何降低空间复杂度。你应该能够将其降低到O(SB)的时间和O(B)的空间（其中B是较大数组的大小，S是较小数组的大小）。

#725.	16.20 	我们可能会多次运行这个算法。如果做更多的预处理，这里有办法优化吗？

#726.	16.18 	你应该能够有一个O(n2)的算法。

#727.	16.7 	你考虑过如何处理a – b中的整数溢出吗？

#728.	16.5 	n!中每一个因子10都意味着n!能被5和2整除。

#729.	16.15 	为了在实现中简单明了，你可能需要使用其他方法和类。

#730.	17.18 	另一种考虑方法是：假设你有一个每个元素所在索引的列表。你能找到包含所有元素的第一个子序列吗？你能找到第二个吗？

#731.	16.4 	如果你正在为N×N的大小进行计算，你的解决方案可能会发生什么变化？

#732.	16.5 	你能计算出5和2的因数的个数吗？需要两者都计算吗？

#733.	17.21 	每个长方形的顶部都有水，水的高度应与左侧最高长方形和右侧最高长方形的较小值相匹配，也就是说，water_on_top[i] = min(tallest_ bar(0->i), tallest_bar(i, n))。

#734.	16.16 	你能把中间部分展开直到满足前面的条件吗？

#735.	17.23 	当你检查一个特定的正方形是否有效时（所有边框为黑色），需要检查在一个坐标的上面（或下面）和这个坐标的左边（或右边）有多少个黑色像素。你能预先计算出给定单元格上面和左边的黑色像素的数量吗？

#736.	16.1 	你也可以尝试使用XOR。

#737.	17.22 	如果同时从起始单词和目标单词开始进行广度优先搜索，结果会怎样？

#738.	17.13 	在现实生活中，我们知道有些路径不会构成一个词。例如，没有以hellothisism开头的单词。能在明知行不通的情况下提前终止吗？

#739.	16.11 	有一个替代的、聪明的（而且非常快速的）解决方案。实际上你可以在线性时间内不用递归求解。如何进行？

#740.	17.18 	考虑使用堆。

#741.	17.21 	你应该能在O(N)时间和O(N)空间中解出该题。



#742.	17.17 	或者，可以将每个较小的字符串插入到trie中。你将如何解决这个问题？时间复杂度是什么？

#743.	16.20 	通过预处理，实际上可以将查找时间降低到O(1)。

#744.	16.5 	你是否考虑过25实际上记录了两次因数5？

#745.	16.16 	你应该能在O(N)时间内解出来。

#746.	16.11 	这样想：你选择K块木板，其有两种不同的类型。对于第一种木板选择10个、第二种木板选择4个的所有方案，它们的和都是相同的。你能遍历所有可能的选择吗？

#747.	17.25 	当矩形看起来无效时，可以使用trie提前终止吗？

#748.	17.13 	如果想提前终止，可以试一试trie。


